detach("package:Biobase", unload = TRUE)
detach("package:edge", unload = TRUE)
detach("package:devtools", unload = TRUE)
detach("package:Biobase", unload = TRUE)
detach("package:BiocGenerics", unload = TRUE)
detach("package:generics", unload = TRUE)
detach("package:genefilter", unload = TRUE)
detach("package:limma", unload = TRUE)
# 2. Installing qvalue
BiocManager::install(c("qvalue"), type = "source", force = TRUE)
# 2. Installing qvalue
BiocManager::install(c('digest', 'Rhtslib', 'xml2'), type = "source", force = TRUE)
# 4. Load Libraries
library(devtools)
library(Biobase)
library(limma)
library(edge)
library(genefilter)
library(qvalue)
# 5. Plotting Parameters
tropical = c("darkorange", "dodgerblue", "hotpink", "limegreen", "yellow")
palette(tropical)
par(pch=19)
# 6. Load the Data
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bottomly_eset.RData")
load(file=con)
close(con)
bot = bottomly.eset
bot
pdata=pData(bot)
head(pdata)
edata=as.matrix(exprs(bot))
head(edata)
fdata = fData(bot)
head(fdata)
ls()
# 7. Log2 transform and removing lowly expressed genes
edata = log2(as.matrix(edata) + 1)
edata = edata[rowMeans(edata) > 10, ]
# 8. Calculating the F-statistic and p-values using the gene filter package
fstats_obj = rowFtests(edata,as.factor(pdata$strain))
hist(fstats_obj$p.value,col=2)
# 9. Construct an adjusted model using the edge package, Strain (variable of interest),
# Lane (adjustment variable), model is not moderated (may get inflated statistics)
edge_study = build_study(edata, grp = pdata$strain,
adj.var = as.factor(pdata$lane.number))
de_obj = lrt(edge_study)
# 9. Construct an adjusted model using the edge package, Strain (variable of interest),
# Lane (adjustment variable), model is not moderated (may get inflated statistics)
edge_study = build_study(edata, grp = pdata$strain, adj.var = as.factor(pdata$lane.number))
de_obj = lrt(edge_study)
# 9. Construct an adjusted model using the edge package, Strain (variable of interest),
# Lane (adjustment variable), model is not moderated (may get inflated statistics)
edge_study = build_study(edata, grp = pdata$strain, adj.var = as.factor(pdata$lane.number))
de_obj = lrt(edge_study)
# 4. Load Libraries
library(goseq)
# 5. Display data
head(supportedGenomes())
detach("package:geneLenDataBase", unload = TRUE)
detach("package:geneLenDataBase", unload = TRUE)
detach("package:goseq", unload = TRUE)
detach("package:geneLenDataBase", unload = TRUE)
# 1. Installing Bioconductor package
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install()
# 2. Installing qvalue
# BiocManager::install("goseq")
# 3. Troubleshooting installing packages
# BiocManager::valid()
# 4. Load Libraries
library(goseq)
# 5. Display data
head(supportedGenomes())
# 6. Display data – Available cases
head(supportedGeneIDs())
# 7. Load data from goseq package
temp_data =read.table(system.file("extdata","Li_sum.txt",
package="goseq"),sep="\t",
header=TRUE,
stringsAsFactors=FALSE)
# 8. First row of the data set
temp_data[1,]
# 9. Remove 1st column of data set and replace it with rownames = gene names
expr= temp_data[,-1]
rownames(expr) = temp_data[,1]
# 10. Remove lowly expressed genes
expr = expr[rowMeans(expr) > 5,]
# 11. Create a group variable, the data doesn't have a group variable
grp=factor(rep(c("Control","Treated"),times=c(4,3)))
grp
# 12. Create a pdata (phenotype) object with just the grp variable in it
pdata  = data.frame(grp)
pdata[1,]
# 13. Passing expression(expr), phenotype data(pdata) and the grp variable you want to model
de = DESeqDataSetFromMatrix(expr, pdata, ~grp)
# 13. Passing expression(expr), phenotype data(pdata) and the grp variable you want to model
library(DESeq2)
de = DESeqDataSetFromMatrix(expr, pdata, ~grp)
# 14. Use DESeq to identify differentially expressed genes
de_fit = DESeq(de)
# 15. Calculate the results using the results function
de_results = results(de_fit)
# 16. Display differentially expressed results
head(de_fit)
# 17. Remove the genes where we can’t calculate a statistic
# 17. A. Filter genes that are differentially expressed < 0.05 (FDR)
genes = as.integer(de_results$padj < 0.05)
# 17. B. Remove data were there wasn't enough data
not_na = !is.na(genes)
# 17. C. Apply row names to match genes to genomic data
names(genes) = rownames(expr)
# 17. D. Remove genes we can't calculate a statistic for
genes = genes[not_na]
# 18. We need to set up a weighting function for all the genes in that genome
pwf=nullp(genes,"hg19","ensGene")
# 19. Use goseq package to calculate the statistics for enrichment
GO.wall=goseq(pwf,"hg19","ensGene")
# 20. Display results
head(GO.wall)
# 21. Selecting a specific category of interest for your analysis
GO.MF=goseq(pwf,"hg19","ensGene",test.cats=c("GO:MF"))
head(GO.MF)
# 8. First row of the data set
temp_data[1,]
# 7. Load data from goseq package
temp_data =read.table(system.file("extdata","Li_sum.txt",
package="goseq"),sep="\t",
header=TRUE,
stringsAsFactors=FALSE)
# 8. First row of the data set
temp_data[1,]
# 9. Remove 1st column of data set and replace it with rownames = gene names
expr= temp_data[,-1]
expr
rownames(expr) = temp_data[,1]
temp_data[,1]
# 10. Remove lowly expressed genes
expr = expr[rowMeans(expr) > 5,]
# 11. Create a group variable, the data doesn't have a group variable
grp=factor(rep(c("Control","Treated"),times=c(4,3)))
grp
# 12. Create a pdata (phenotype) object with just the grp variable in it
pdata  = data.frame(grp)
pdata[1,]
head(pdata)
head(expr)
# 13. Passing expression(expr), phenotype data(pdata) and the grp variable you want to model
library(DESeq2)
de = DESeqDataSetFromMatrix(expr, pdata, ~grp)
head(de)
# 16. Display differentially expressed results
head(de_results)
# 16. Display differentially expressed results
head(de_results)
# 6. Load in data from a connection
con = url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bodymap_eset.RData")
# 7. Close the connection
close(con)
# 8. Display body map expression set
ls()
# 9. Re-assign bodymap.eset to a smaller name
bm = bodymap.eset
# 5. C. I. Load in data from a connection
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bottomly_eset.RData")
load(file=con)
close(con)
ls()
bot = bottomly.eset
bot
pdata_bot=pData(bot)
summary(edata)
summary(edata)
# 5. C. I. Load in data from a connection
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bottomly_eset.RData")
load(file=con)
close(con)
ls()
bot = bottomly.eset
bot
pdata_bot=pData(bot)
library(BiocGenerics)
library(AnnotationDbi)
# 5. C. I. Load in data from a connection
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bottomly_eset.RData")
load(file=con)
close(con)
ls()
bot = bottomly.eset
bot
pdata_bot=pData(bot)
head(pdata_bot)
fdata_bot = featureData(bot)
head(fdata_bot)
edata = exprs(bot)
head(edata, n=1)
summary(edata)
table(pdata$age)
table(pdata$age,useNA="ifany")
# 14. Displaying gender type information from phenotype data
table(pdata$gender)
# 5. C. I. Load in data from a connection
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bottomly_eset.RData")
load(file=con)
close(con)
ls()
bot = bottomly.eset
bot
pdata_bot=pData(bot)
head(pdata_bot)
fdata_bot = featureData(bot)
head(fdata_bot)
edata = exprs(bot)
head(edata, n=1)
# 5. C. II. Check genomic data for NAs
is.na(edata)[1,]
library(tidyverse)
library(dplyr)
library(tibble)
# 5. C. III. Change expression set to a data frame
edata1 = as.data.frame(edata)
edata2 = as_tibble(edata)
edata3 = data.frame(edata)
knitr::opts_chunk$set(echo = TRUE)
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
knitr::opts_chunk$set(echo = TRUE)
# C:\Users\Ajay_\AppData\Local\R\cache\R\reticulate\uv\cache\archive-v0\Y4pwbi6LQG6ixjCEO2rPq\Lib\site-packages
pip install pandas
# C:\Users\Ajay_\AppData\Local\R\cache\R\reticulate\uv\cache\archive-v0\Y4pwbi6LQG6ixjCEO2rPq\Lib\site-packages
install.packages("pip")
install.packages("reticulate")
library(reticulate)
# py_install("Bio")
reticulate::repl_python()
reticulate::repl_python()
setwd("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7")
# 1. Gene Expression Analysis - Microarrays
# Gene expression analysis is a cornerstone of bioinformatics and molecular biology,
# providing insights into cellular functions, regulations, and underlying mechanisms
# of diseases. With the advancement of genomic technologies, microarrays have emerged
# as a powerful technique for measuring the expression levels of thousands of genes
# simultaneously. This chapter aims to guide readers through the process of analyzing
# microarray data using R, a widely-used programming language in bioinformatics,
# emphasizing the tools and techniques that facilitate gene expression analysis.
# 1. A. Overview of Microarrays
# Microarrays are a high-throughput technology that allows researchers to analyze
# gene expression profiles across various conditions or treatments. Each microarray
# consists of thousands of DNA probes, each corresponding to a specific gene.
# The basic principle involves hybridizing labelled RNA or cDNA samples to the
# probes, where the fluorescent signal intensity at each spot indicates the level
# of gene expression.
# 1. A. I. Types of Microarrays
# * __cDNA Microarrays__: Composed of known cDNAs and used for comparative analysis
# of gene expression.
# * __Oligonucleotide  Microarrays__: Contain short, synthetic oligonucleotides
# that provide high specificity and sensitivity for gene expression profiling.
# * __SNP Arrays__: Used to detect single nucleotide polymorphisms rather than
# gene expression.
# 1. B. Data Acquisition and Pre-processing.
# Before diving into analysis, the first step is acquiring the raw microarray data.
# This may involve downloading data from repositories such as the __Gene Expression
# Omnibus (GEO)__ or __The European Nucleotide Archive (ENA)__. Once data is
# obtained, pre-processing is crucial.
# 1. B. I. Loading Data into R
# R provides several packages to facilitate the import and management of microarray
# data. Below is a code snippet demonstrating how to load data from GEO data set
# using the "GEOquery" package.
# Install and load necessary packages
# install.packages("BiocManager")
# BiocManager::install("GEOquery")
library(GEOquery)
library(Biobase)
# Load GEO dataset
geo_dataset <- getGEO("GSE57820", GSEMatrix = TRUE)
# Split geo_dataset into pdata, fdata and expression data
ls()
geo = geo_dataset
geo
pdata_geo=geo[["GSE57820_series_matrix.txt.gz"]]@phenoData
head(pdata_geo)
pdata_geo <- pData(pdata_geo)
head(pdata_geo)
fdata_geo = geo[["GSE57820_series_matrix.txt.gz"]]@featureData
head(fdata_geo)
expression_data = geo[["GSE57820_series_matrix.txt.gz"]]@assayData[["exprs"]]
head(expression_data, n = 5)
# 1. B. II. Quality Control
# Quality control is essential to ensure that the data is reliable and suitable
# for analysis. This step involves identifying and removing low-quality samples
# or outliers. Common tools for visualizaing data quality include box plots,
# density plots and principal component analysis (PCA).
# Boxplot
boxplot(expression_data, main = "Quality Control: Boxplot of Expression Data")
# PCA for outlier detection
pca_result <- prcomp(t(expression_data), scale. = TRUE)
plot(pca_result$x, main = "PCA of Expression Data")
# 1. B. III. Normalization
# Normalization adjusts the data to account for systematic biases and ensures
# that differences in expression levels are biological rather than technical
# artifacts. Several methods exist, with the "RMA" (Robust Multi-array Average)
# algorithm being a commonly used approach for background correction, normalization,
# and summarization.
# Normalizing data using RMA method
# BiocManager::install("affy")
library(affy)
# normalized_data <- rma(geo_dataset[[1]])
# Error: unable to find an inherited method for function ‘probeNames’ for signature
# ‘object = "ExpressionSet"’
# The error you are seeing:
# Error: unable to find an inherited method for function ‘probeNames’ for signature
# ‘object = "ExpressionSet"’ indicates that the rma function is expecting an input
# of a different class (usually AffyBatch), but you are providing an object of class
# ExpressionSet. The rma function from the affy package does not directly operate
# on an ExpressionSet; it expects raw CEL files read using ReadAffy() or similar
# functions.
# Here’s a structured way to solve this:
# Download Raw CEL Files (preferred for rma)
# Example GEO accession
# geo_id <- "GSE57820"
# Download the GEO dataset including raw CEL files
# geo_data <- getGEO(geo_id, GSEMatrix = FALSE)
# Check if raw CEL files exist:
# names(geo_data)   # Should include CEL files under supplementary files
# Read CEL Files Before RMA rma works on AffyBatch objects, not ExpressionSet:
# Suppose CEL files are downloaded to current directory
# cel_files <- list.celfiles(".", full.names = TRUE)
# affy_data <- ReadAffy(filenames = cel_files)
# Normalize using RMA
# normalized_data <- rma(affy_data)
# If You Only Have ExpressionSet
# If you only have an ExpressionSet already, RMA has likely already been applied to the data.
# Use exprs() to access normalized expression values:
# Access expression matrix
normalized_data <- exprs(geo_dataset[[1]])
head(normalized_data)
# Applying rma() again is not necessary and will error out because ExpressionSet is not compatible with rma.
# 1. C. Differential Expression Analysis
# Once the data is pre-processed and normalized, the focus shifts to identifying
# differentially expressed genes (DEGs) across experimental conditions. The "limma"
# package is a popular choice for this purpose, utilizing linear modelling and
# empirical Bayes methods
# 1. C. I. Design Matrix
# Before performing differential expression analysis, define the experimental design
# with a design matrix that captures the conditions being compared.
# Create a design matrix
# GSM1394594 GSM1394595 GSM1394596 GSM1394597 GSM1394598 GSM1394599 = treatment samples
# GSM1394600 GSM1394601 GSM1394602 GSM1394603 GSM1394604 GSM1394605 = negative control samples
library(dplyr)
# Sample data setup (replace with your actual data)
sample_names <- paste0("Sample", 1:12)
sample_names
groups <- factor(rep(c("Treatment", "Control"), each = 6))
groups
pheno_data <- data.frame(SampleName = sample_names, Group = groups)
pheno_data
rownames(pheno_data) <- pheno_data$SampleName # set sample names as row names
rownames(pheno_data)
# Using the formula ~Group Default reference is first level, "Control"
mod <- model.matrix(~ pheno_data$Group, data = pdata_geo)
mod
# 1. C. II. Fit Model and Conduct Analysis
# After setting up the design matrix, fit the linear model for each gene and
# apply statistical tests to identify DEGs.
# Load the Libraries
library(limma)
# Fitting the linear model
fit <- lmFit(normalized_data, mod)
fit <- eBayes(fit)
head(fit)
summary(fit)
# Extracting DEGs
results <- topTable(fit, adjust.method = "BH", sort.by = "P", number = 100)
results
# 1. C. III. Result Interpretation
# The output from the differential expression analysis includes log-fold changes,
# p-values and adjusted p-values. Using a volcano plot, one can visually represent
# the results, highlighting significantly altered genes.
# Volcano Plot
volcano_data <- data.frame(logFC = results$logFC, -log10(results$P.Value))
volcano_data
plot(volcano_data$logFC, volcano_data$negLogPval, pch=20, main="Volcano Plot",
xlab = "Log Fold Change", ylab = "Statistical Significance (-log10)")
abline(h = -log10(0.05), col="red")
# 1. D. Functional Enrichment Analysis
# Once DEGs are identified, functional enrichment analysis can elucidate biological
# pathways and processes significantly associated with the list of altered genes.
# Tools like "clusterProfiler" facilitate pathway analysis, such as Gene Ontology
# (GO) and Kyoto Encyclopedia of Genes and Genomes (KEGG).
# Install "clusterProfiler" and "BSgenome.Hsapiens.UCSC.hg38" packages
BiocManager::install("clusterProfiler")
BiocManager::install("org.Hs.egGO")
BiocManager::install("topGO")
BiocManager::install("Rgraphviz")
# Install gprofiler2 if not already installed
if (!requireNamespace("gprofiler2", quietly = TRUE)) {
install.packages("gprofiler2")
}
# Load libraries
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(gprofiler2)
library(topGO)
library(Rgraphviz)
# Example: Illumina probe IDs (replace with your own list)
illumina_ids <- c(rownames(results))
# Convert Illumina IDs to Entrez Gene IDs for human (hsapiens)
# The 'target' parameter specifies the output namespace
# The 'organism' parameter specifies the species
conversion_result <- gconvert(
query = illumina_ids,
organism = "hsapiens",
target = "ENTREZGENE_ACC",  # Entrez Gene ID
filter_na = TRUE            # Remove rows with no match
)
# Display the conversion table
print(conversion_result)
# Performing GO analysis
go_results <- enrichGO(gene = conversion_result$name, OrgDb = org.Hs.eg.db,
keyType = "SYMBOL", pAdjustMethod = "BH")
plotGOgraph(go_results)
# Heatmap Generation
heatmapData <- normalized_data[rownames(results[results$adj.P.Val < 0.05,]),]
normalized_data[rownames(results[results$adj.P.Val < 0.05,])
pheatmap(heatmapData, clustering_distance_rows = "correlation",
pheatmap(heatmapData, clustering_distance_rows = "correlation", clustering_distance_cols = "correlation")
library(pheatmap)
pheatmap(heatmapData, clustering_distance_rows = "correlation", clustering_distance_cols = "correlation")
pheatmap(heatmapData, clustering_distance_rows = "correlation",
clustering_distance_cols = "correlation")
pheatmap(heatmapData, clustering_distance_rows = "correlation",
clustering_distance_cols = "correlation")
setwd("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/Microarrays")
library(affy)
# Read in the CEL files
rawData <- ReadAffy()
View(rawData)
library(oligo)
# Install "oligo" if not already installed
if (!requireNamespace("oligo", quietly = TRUE)) {
install.packages("oligo")
}
# Install "oligo" if not already installed
BiocManager::install("oligo")
library(oligo)
# Read in the CEL files
rawData_affy <- ReadAffy()
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
library(oligo)
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
BiocManager::install("illuminaio")
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
library(illuminaio)
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
getGEOSuppFiles("GSE86829")
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
# Read in the IDAT files for Illumina arrays
rawData_Ill <- read.idat("D:/Ajay Files/R Programming for Bioinformatics/Chapter 7/IDAT example files")
# Create boxplots for quality assessment
boxplot(rawData_affy, main = "Boxplot of Raw Data")
# Generate quality metrics
affyQCMetrics <- affyQC(rawData_affy)
BiocManager::install("affyPLM")
library(affyPLM)
fit <- fitPLM(rawData_affy)
NUSE(fit)
RLE(fit)
fit <- fitPLM(rawData_affy)
fit
rawData_affy
summary(fit)
fit
View(rawData_affy)
bg_correctedData <- mas5(bgCorrect = TRUE)
# Perform background correction
bg_correctedData <- mas5(bg.correct(rawData_affy))
bgCorrectedData <- mas5(rawData_affy)
bgCorrectedData
rawData_affy
